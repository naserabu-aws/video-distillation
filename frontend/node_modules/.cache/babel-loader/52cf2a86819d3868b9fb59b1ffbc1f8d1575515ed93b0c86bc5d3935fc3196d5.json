{"ast":null,"code":"import { sleep } from \"./utils/sleep\";\nimport { WaiterState } from \"./waiter\";\nconst exponentialBackoffWithJitter = (minDelay, maxDelay, attemptCeiling, attempt) => {\n  if (attempt > attemptCeiling) return maxDelay;\n  const delay = minDelay * 2 ** (attempt - 1);\n  return randomInRange(minDelay, delay);\n};\nconst randomInRange = (min, max) => min + Math.random() * (max - min);\nexport const runPolling = async ({\n  minDelay,\n  maxDelay,\n  maxWaitTime,\n  abortController,\n  client,\n  abortSignal\n}, input, acceptorChecks) => {\n  const observedResponses = {};\n  const {\n    state,\n    reason\n  } = await acceptorChecks(client, input);\n  if (reason) {\n    const message = createMessageFromResponse(reason);\n    observedResponses[message] |= 0;\n    observedResponses[message] += 1;\n  }\n  if (state !== WaiterState.RETRY) {\n    return {\n      state,\n      reason,\n      observedResponses\n    };\n  }\n  let currentAttempt = 1;\n  const waitUntil = Date.now() + maxWaitTime * 1000;\n  const attemptCeiling = Math.log(maxDelay / minDelay) / Math.log(2) + 1;\n  while (true) {\n    if (abortController?.signal?.aborted || abortSignal?.aborted) {\n      const message = \"AbortController signal aborted.\";\n      observedResponses[message] |= 0;\n      observedResponses[message] += 1;\n      return {\n        state: WaiterState.ABORTED,\n        observedResponses\n      };\n    }\n    const delay = exponentialBackoffWithJitter(minDelay, maxDelay, attemptCeiling, currentAttempt);\n    if (Date.now() + delay * 1000 > waitUntil) {\n      return {\n        state: WaiterState.TIMEOUT,\n        observedResponses\n      };\n    }\n    await sleep(delay);\n    const {\n      state,\n      reason\n    } = await acceptorChecks(client, input);\n    if (reason) {\n      const message = createMessageFromResponse(reason);\n      observedResponses[message] |= 0;\n      observedResponses[message] += 1;\n    }\n    if (state !== WaiterState.RETRY) {\n      return {\n        state,\n        reason,\n        observedResponses\n      };\n    }\n    currentAttempt += 1;\n  }\n};\nconst createMessageFromResponse = reason => {\n  if (reason?.$responseBodyText) {\n    return `Deserialization error for body: ${reason.$responseBodyText}`;\n  }\n  if (reason?.$metadata?.httpStatusCode) {\n    if (reason.$response || reason.message) {\n      return `${reason.$response.statusCode ?? reason.$metadata.httpStatusCode ?? \"Unknown\"}: ${reason.message}`;\n    }\n    return `${reason.$metadata.httpStatusCode}: OK`;\n  }\n  return String(reason?.message ?? JSON.stringify(reason) ?? \"Unknown\");\n};","map":{"version":3,"names":["sleep","WaiterState","exponentialBackoffWithJitter","minDelay","maxDelay","attemptCeiling","attempt","delay","randomInRange","min","max","Math","random","runPolling","maxWaitTime","abortController","client","abortSignal","input","acceptorChecks","observedResponses","state","reason","message","createMessageFromResponse","RETRY","currentAttempt","waitUntil","Date","now","log","signal","aborted","ABORTED","TIMEOUT","$responseBodyText","$metadata","httpStatusCode","$response","statusCode","String","JSON","stringify"],"sources":["/Users/naserabu/Desktop/video distillation/frontend/node_modules/@smithy/util-waiter/dist-es/poller.js"],"sourcesContent":["import { sleep } from \"./utils/sleep\";\nimport { WaiterState } from \"./waiter\";\nconst exponentialBackoffWithJitter = (minDelay, maxDelay, attemptCeiling, attempt) => {\n    if (attempt > attemptCeiling)\n        return maxDelay;\n    const delay = minDelay * 2 ** (attempt - 1);\n    return randomInRange(minDelay, delay);\n};\nconst randomInRange = (min, max) => min + Math.random() * (max - min);\nexport const runPolling = async ({ minDelay, maxDelay, maxWaitTime, abortController, client, abortSignal }, input, acceptorChecks) => {\n    const observedResponses = {};\n    const { state, reason } = await acceptorChecks(client, input);\n    if (reason) {\n        const message = createMessageFromResponse(reason);\n        observedResponses[message] |= 0;\n        observedResponses[message] += 1;\n    }\n    if (state !== WaiterState.RETRY) {\n        return { state, reason, observedResponses };\n    }\n    let currentAttempt = 1;\n    const waitUntil = Date.now() + maxWaitTime * 1000;\n    const attemptCeiling = Math.log(maxDelay / minDelay) / Math.log(2) + 1;\n    while (true) {\n        if (abortController?.signal?.aborted || abortSignal?.aborted) {\n            const message = \"AbortController signal aborted.\";\n            observedResponses[message] |= 0;\n            observedResponses[message] += 1;\n            return { state: WaiterState.ABORTED, observedResponses };\n        }\n        const delay = exponentialBackoffWithJitter(minDelay, maxDelay, attemptCeiling, currentAttempt);\n        if (Date.now() + delay * 1000 > waitUntil) {\n            return { state: WaiterState.TIMEOUT, observedResponses };\n        }\n        await sleep(delay);\n        const { state, reason } = await acceptorChecks(client, input);\n        if (reason) {\n            const message = createMessageFromResponse(reason);\n            observedResponses[message] |= 0;\n            observedResponses[message] += 1;\n        }\n        if (state !== WaiterState.RETRY) {\n            return { state, reason, observedResponses };\n        }\n        currentAttempt += 1;\n    }\n};\nconst createMessageFromResponse = (reason) => {\n    if (reason?.$responseBodyText) {\n        return `Deserialization error for body: ${reason.$responseBodyText}`;\n    }\n    if (reason?.$metadata?.httpStatusCode) {\n        if (reason.$response || reason.message) {\n            return `${reason.$response.statusCode ?? reason.$metadata.httpStatusCode ?? \"Unknown\"}: ${reason.message}`;\n        }\n        return `${reason.$metadata.httpStatusCode}: OK`;\n    }\n    return String(reason?.message ?? JSON.stringify(reason) ?? \"Unknown\");\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}